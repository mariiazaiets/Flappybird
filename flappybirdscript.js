var cvs = document.getElementById("canvas"); //сюди вміщений html об'єкт з id="canvas"
var ctx = cvs.getContext("2d"); //відповідає за вигляд нашої гри(2D гра)

//Далі займемося загрузкою зображень
var bird = new Image(); //Ці об'єкти створюються на оснрові класу Image
var bg = new Image(); //задній фон
var fg = new Image(); //передній фон
var pipeUp = new Image(); //перешкода зверху
var pipeBottom = new Image(); //перешкода знизу

//Сама загрузка зображень
bird.src = "img/flappy_bird_bird.png";
bg.src = "img/flappy_bird_bg.png";
fg.src = "img/flappy_bird_fg.png";
pipeUp.src = "img/flappy_bird_pipeUp.png";
pipeBottom.src = "img/flappy_bird_pipeBottom.png";

//Звукові файли
var fly = new Audio();
var score_audio = new Audio();

fly.src = "audio/feel.mp3";
score_audio.src = "audio/we.mp3";

//Створимо змінну gap яка буде служити відступом посередині між верхньою колоною та нижньою
var gap = 90;

//При натисканні на будь-яку клавішу наша пташка підлітатиме до верху (при натисканні будь-якої кнопки має зробити якийсь метод)
document.addEventListener("keydown", moveUp);

//Реалізовуємо функцію moveUp
function moveUp() {
    yPos -= 25; //ігрик позицію буде підіймати на 20 пікселів вище, тобто саму пташку
    fly.play();
}

//Створюємо блоки. Для початку ставимо новий масив
var pipe = [];      //пустий масив
pipe [0] = {        //створюємо один об'єкт у масиві через фігурні дужки. В об'єкт можна вміщувати декілька значень, у нас тут буде дві координати по х(іксу) та у(ігрику)
    x : cvs.width,  //Буде знаходитися поза межами екрану
    y : 0           //Першопочатково буде знаходитися в точці 0
}
//Змінні які відповідатимуть за позицію пташки
var xPos = 10;
var yPos = 150;
var grav = 1.5;

var score = 0;

//Тепер намалюємо всі об'єкти в canvas. Для цього використовуємо функцію. У ньому ми будемо иалювати наші блоки, копіюємо їх знизу за циклом
function draw() {
    ctx.drawImage(bg, 0, 0);

    //Малювання блоків буде проходити в циклі, тому створюємо цикл
    for(var i = 0; i < pipe.length; i++) {
        ctx.drawImage(pipeUp, pipe[i].x, pipe[i].y);
        ctx.drawImage(pipeBottom, pipe[i].x, pipe[i].y + pipeUp.height + gap);

        //Тепер щоб ці блоки пересовувались, ми беремо наш блок який ми розглядаємо у циклі, а саме позицію по х(іксу) та віднімаємо від неї 1
        pipe[i].x--;

        //Для того щоб купа блоків постійно йшли один за одним, ми добавляємо нову перевірку. В циклі ми беремо наш конкретний блок, його позицію по х і якщо вона буде дорівнювати наприклад 125px, то вже буде створюватисб новий блок
        if(pipe[i].x == 125) {
            pipe.push({      //Будемо добавляти новий елемент в масив pipe. Це у нас не просто елемент, а і об'єкт, тому ставимо фігурні дужки
                x : cvs.width,   //Щоб блоки з'являлися за екраном, типу ми їх не бачимо, але вони вже з'являються
                y : Math.floor(Math.random() * pipeUp.height) - pipeUp.height     //Тут по ігрику пишемо випадкове число, щоб проходи між блоками кожного разу були на різному місці, не завжди на однаковому рівні. Тут ми використовуємо клас Math, метод floor для округлення чисел
             })     
        }

        //Тепер пропишемо складну умову, в якій ми перевіряємо ЗІТКНЕННЯ пташки З БЛОКАМИ. (Тобто перевіряємо якщо пташка знаходиться у межах ширини блоку, (або це початок блоку, або його кінець чи середина) і якщо вона знаходиться у межах висоти цього блоку, якщо доторкнулась наприклад до цього блоку і до нижнього fg(її ігрик позиція та ігрик позиція блоку i fg співпадають) то пташка зіткнулась, а отже ми можемо перезапустити всю сторінку та почати гру заново
        if(xPos + bird.width >= pipe[i].x 
            && xPos <= pipe[i].x + pipeUp.width 
            && (yPos <= pipe[i].y + pipeUp.height 
                || yPos + bird.height >= pipe[i].y + pipeUp.height + gap)
                || yPos + bird.height >= cvs.height - fg.height) {
                    location.reload(); //Перезавантаження сторінки
                }

        //Добавимо кількість балів
        if(pipe[i].x == 5) {
            score++;
            score_audio.play();
            }
        }

    //ctx.drawImage(pipeUp, 100, 0);
   // ctx.drawImage(pipeBottom, 100, 0 + pipeUp.height + gap);

    ctx.drawImage(fg, 0, cvs.height - fg.height);
    ctx.drawImage(bird, xPos, yPos);

    yPos += grav;
    requestAnimationFrame(draw); //Тут ми вказуємо те, що наша пташка ніби під дією гравітації падає зі своєї початкової точки донизу

    //Виводимо надпис score на екран
    ctx.fillStyle = "#000";
    ctx.font = "24px Verdana";
    ctx.fillText("Score: " + score, 10, cvs.height - 20)
}

//Викликаємо цю функцію (ми можемо написати "draw();" це не буде помилкою, АЛЕ нам потрібно щоб всі зображення були завантажені, а лиш після цього ми викликали функцію яка малює ці зображення)
pipeBottom.onload = draw; //onload - після того як загрузиться, викликаємо метод
